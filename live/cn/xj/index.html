<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>新疆卫视</title>
	</head>
	<body>
		<script>
			// 使用严格模式
			"use strict";
			/**
			 * 纯JavaScript实现MD5算法
			 * 解决所有浏览器的MD5兼容性问题
			 * @param {string} string 要计算的字符串
			 * @returns {string} MD5哈希值（和PHP md5结果完全一致）
			 */
			function md5Encode(string) {
				// 循环左移
				const rotLeft = (lValue, iShiftBits) => (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
				// 无符号加法
				const addUnsigned = (lX, lY) => {
					let lResult;
					const lX8 = lX & 0x80000000;
					const lY8 = lY & 0x80000000;
					const lX4 = lX & 0x40000000;
					const lY4 = lY & 0x40000000;
					lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
					if (lX4 & lY4) return lResult ^ 0x80000000 ^ lX8 ^ lY8;
					if (lX4 | lY4) {
						return lResult & 0x40000000 ?
							lResult ^ 0xC0000000 ^ lX8 ^ lY8 :
							lResult ^ 0x40000000 ^ lX8 ^ lY8;
					}
					return lResult ^ lX8 ^ lY8;
				};
				// 核心逻辑函数
				const _F = (x, y, z) => (x & y) | ((~x) & z);
				const _G = (x, y, z) => (x & z) | (y & (~z));
				const _H = (x, y, z) => x ^ y ^ z;
				const _I = (x, y, z) => y ^ (x | (~z));
				// 迭代函数
				const coreIter = (fn, a, b, c, d, x, s, ac) => {
					a = addUnsigned(a, addUnsigned(addUnsigned(fn(b, c, d), x), ac));
					return addUnsigned(rotLeft(a, s), b);
				};
				// 转换为字数组
				const convertToWordArray = (str) => {
					const len = str.length;
					const wordCountTemp = len + 8;
					const wordCount = ((wordCountTemp - (wordCountTemp % 64)) / 64 + 1) * 16;
					const wordArray = Array(wordCount - 1);
					let bytePos = 0,
						byteCount = 0;
					while (byteCount < len) {
						const wc = (byteCount - (byteCount % 4)) / 4;
						bytePos = (byteCount % 4) * 8;
						wordArray[wc] = (wordArray[wc] | (str.charCodeAt(byteCount) << bytePos));
						byteCount++;
					}
					const wc = (byteCount - (byteCount % 4)) / 4;
					bytePos = (byteCount % 4) * 8;
					wordArray[wc] = wordArray[wc] | (0x80 << bytePos);
					wordArray[wordCount - 2] = len << 3;
					wordArray[wordCount - 1] = len >>> 29;
					return wordArray;
				};
				// 字转十六进制
				const wordToHex = (val) => {
					let hex = "";
					for (let i = 0; i <= 3; i++) {
						const byte = (val >>> (i * 8)) & 255;
						hex += ("0" + byte.toString(16)).slice(-2);
					}
					return hex;
				};
				// 常量定义
				const SHIFTS = {
					S11: 7,
					S12: 12,
					S13: 17,
					S14: 22,
					S21: 5,
					S22: 9,
					S23: 14,
					S24: 20,
					S31: 4,
					S32: 11,
					S33: 16,
					S34: 23,
					S41: 6,
					S42: 10,
					S43: 15,
					S44: 21
				};
				// 主逻辑
				const wordArray = convertToWordArray(string.replace(/\r\n/g, "\n"));
				let a = 0x67452301,
					b = 0xEFCDAB89,
					c = 0x98BADCFE,
					d = 0x10325476;
				for (let k = 0; k < wordArray.length; k += 16) {
					let AA = a,
						BB = b,
						CC = c,
						DD = d;
					// 四轮迭代
					a = coreIter(_F, a, b, c, d, wordArray[k + 0], SHIFTS.S11, 0xD76AA478);
					d = coreIter(_F, d, a, b, c, wordArray[k + 1], SHIFTS.S12, 0xE8C7B756);
					c = coreIter(_F, c, d, a, b, wordArray[k + 2], SHIFTS.S13, 0x242070DB);
					b = coreIter(_F, b, c, d, a, wordArray[k + 3], SHIFTS.S14, 0xC1BDCEEE);
					a = coreIter(_F, a, b, c, d, wordArray[k + 4], SHIFTS.S11, 0xF57C0FAF);
					d = coreIter(_F, d, a, b, c, wordArray[k + 5], SHIFTS.S12, 0x4787C62A);
					c = coreIter(_F, c, d, a, b, wordArray[k + 6], SHIFTS.S13, 0xA8304613);
					b = coreIter(_F, b, c, d, a, wordArray[k + 7], SHIFTS.S14, 0xFD469501);
					a = coreIter(_F, a, b, c, d, wordArray[k + 8], SHIFTS.S11, 0x698098D8);
					d = coreIter(_F, d, a, b, c, wordArray[k + 9], SHIFTS.S12, 0x8B44F7AF);
					c = coreIter(_F, c, d, a, b, wordArray[k + 10], SHIFTS.S13, 0xFFFF5BB1);
					b = coreIter(_F, b, c, d, a, wordArray[k + 11], SHIFTS.S14, 0x895CD7BE);
					a = coreIter(_F, a, b, c, d, wordArray[k + 12], SHIFTS.S11, 0x6B901122);
					d = coreIter(_F, d, a, b, c, wordArray[k + 13], SHIFTS.S12, 0xFD987193);
					c = coreIter(_F, c, d, a, b, wordArray[k + 14], SHIFTS.S13, 0xA679438E);
					b = coreIter(_F, b, c, d, a, wordArray[k + 15], SHIFTS.S14, 0x49B40821);
					a = coreIter(_G, a, b, c, d, wordArray[k + 1], SHIFTS.S21, 0xF61E2562);
					d = coreIter(_G, d, a, b, c, wordArray[k + 6], SHIFTS.S22, 0xC040B340);
					c = coreIter(_G, c, d, a, b, wordArray[k + 11], SHIFTS.S23, 0x265E5A51);
					b = coreIter(_G, b, c, d, a, wordArray[k + 0], SHIFTS.S24, 0xE9B6C7AA);
					a = coreIter(_G, a, b, c, d, wordArray[k + 5], SHIFTS.S21, 0xD62F105D);
					d = coreIter(_G, d, a, b, c, wordArray[k + 10], SHIFTS.S22, 0x2441453);
					c = coreIter(_G, c, d, a, b, wordArray[k + 15], SHIFTS.S23, 0xD8A1E681);
					b = coreIter(_G, b, c, d, a, wordArray[k + 4], SHIFTS.S24, 0xE7D3FBC8);
					a = coreIter(_G, a, b, c, d, wordArray[k + 9], SHIFTS.S21, 0x21E1CDE6);
					d = coreIter(_G, d, a, b, c, wordArray[k + 14], SHIFTS.S22, 0xC33707D6);
					c = coreIter(_G, c, d, a, b, wordArray[k + 3], SHIFTS.S23, 0xF4D50D87);
					b = coreIter(_G, b, c, d, a, wordArray[k + 8], SHIFTS.S24, 0x455A14ED);
					a = coreIter(_G, a, b, c, d, wordArray[k + 13], SHIFTS.S21, 0xA9E3E905);
					d = coreIter(_G, d, a, b, c, wordArray[k + 2], SHIFTS.S22, 0xFCEFA3F8);
					c = coreIter(_G, c, d, a, b, wordArray[k + 7], SHIFTS.S23, 0x676F02D9);
					b = coreIter(_G, b, c, d, a, wordArray[k + 12], SHIFTS.S24, 0x8D2A4C8A);
					a = coreIter(_H, a, b, c, d, wordArray[k + 5], SHIFTS.S31, 0xFFFA3942);
					d = coreIter(_H, d, a, b, c, wordArray[k + 8], SHIFTS.S32, 0x8771F681);
					c = coreIter(_H, c, d, a, b, wordArray[k + 11], SHIFTS.S33, 0x6D9D6122);
					b = coreIter(_H, b, c, d, a, wordArray[k + 14], SHIFTS.S34, 0xFDE5380C);
					a = coreIter(_H, a, b, c, d, wordArray[k + 1], SHIFTS.S31, 0xA4BEEA44);
					d = coreIter(_H, d, a, b, c, wordArray[k + 4], SHIFTS.S32, 0x4BDECFA9);
					c = coreIter(_H, c, d, a, b, wordArray[k + 7], SHIFTS.S33, 0xF6BB4B60);
					b = coreIter(_H, b, c, d, a, wordArray[k + 10], SHIFTS.S34, 0xBEBFBC70);
					a = coreIter(_H, a, b, c, d, wordArray[k + 13], SHIFTS.S31, 0x289B7EC6);
					d = coreIter(_H, d, a, b, c, wordArray[k + 0], SHIFTS.S32, 0xEAA127FA);
					c = coreIter(_H, c, d, a, b, wordArray[k + 3], SHIFTS.S33, 0xD4EF3085);
					b = coreIter(_H, b, c, d, a, wordArray[k + 6], SHIFTS.S34, 0x4881D05);
					a = coreIter(_H, a, b, c, d, wordArray[k + 9], SHIFTS.S31, 0xD9D4D039);
					d = coreIter(_H, d, a, b, c, wordArray[k + 12], SHIFTS.S32, 0xE6DB99E5);
					c = coreIter(_H, c, d, a, b, wordArray[k + 15], SHIFTS.S33, 0x1FA27CF8);
					b = coreIter(_H, b, c, d, a, wordArray[k + 2], SHIFTS.S34, 0xC4AC5665);
					a = coreIter(_I, a, b, c, d, wordArray[k + 0], SHIFTS.S41, 0xF4292244);
					d = coreIter(_I, d, a, b, c, wordArray[k + 7], SHIFTS.S42, 0x432AFF97);
					c = coreIter(_I, c, d, a, b, wordArray[k + 14], SHIFTS.S43, 0xAB9423A7);
					b = coreIter(_I, b, c, d, a, wordArray[k + 5], SHIFTS.S44, 0xFC93A039);
					a = coreIter(_I, a, b, c, d, wordArray[k + 12], SHIFTS.S41, 0x655B59C3);
					d = coreIter(_I, d, a, b, c, wordArray[k + 3], SHIFTS.S42, 0x8F0CCC92);
					c = coreIter(_I, c, d, a, b, wordArray[k + 10], SHIFTS.S43, 0xFFEFF47D);
					b = coreIter(_I, b, c, d, a, wordArray[k + 1], SHIFTS.S44, 0x85845DD1);
					a = coreIter(_I, a, b, c, d, wordArray[k + 8], SHIFTS.S41, 0x6FA87E4F);
					d = coreIter(_I, d, a, b, c, wordArray[k + 15], SHIFTS.S42, 0xFE2CE6E0);
					c = coreIter(_I, c, d, a, b, wordArray[k + 6], SHIFTS.S43, 0xA3014314);
					b = coreIter(_I, b, c, d, a, wordArray[k + 13], SHIFTS.S44, 0x4E0811A1);
					a = coreIter(_I, a, b, c, d, wordArray[k + 4], SHIFTS.S41, 0xF7537E82);
					d = coreIter(_I, d, a, b, c, wordArray[k + 11], SHIFTS.S42, 0xBD3AF235);
					c = coreIter(_I, c, d, a, b, wordArray[k + 2], SHIFTS.S43, 0x2AD7D2BB);
					b = coreIter(_I, b, c, d, a, wordArray[k + 9], SHIFTS.S44, 0xEB86D391);
					// 累加
					a = addUnsigned(a, AA);
					b = addUnsigned(b, BB);
					c = addUnsigned(c, CC);
					d = addUnsigned(d, DD);
				}
				return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
			}
			/**
			 * 获取指定ID的电视直播流地址
			 * @param {string|number} Id 频道ID
			 * @returns {Promise<string|null>} 播放流地址
			 */
			async function getTVChannelStreamUrl(Id) {
				// 生成毫秒级时间戳
				const t = String(Date.now());
				try {
					// 发送GET请求
					const response = await fetch('https://slstapi.xjtvs.com.cn/api/TVLiveV100/TVChannelList?type=1&stamp=' +
						t + '&sign=' + md5Encode('@#@$AXdm123%)(ds' + t + 'api/TVLiveV100/TVChannelList') +
						'&json=true');
					if (!response.ok) throw new Error('HTTP状态码: ' + response.status);
					const data = await response.json();
					// 匹配对应ID的播放地址
					if (data.success && Array.isArray(data.data)) {
						for (const channel of data.data) {
							if (channel.Id == Id) {
								return window.location.href = channel.PlayStreamUrl
							}
						}
					}
					return alert('未找到对应ID');
				} catch (error) {
					return alert('请求失败: ' + error.message);
				}
			}
			// 程序执行
			const urlParams = new URLSearchParams(window.location.search);
			const idFromUrl = urlParams.get('id') || 1;
			getTVChannelStreamUrl(idFromUrl);
		</script>
	</body>
</html>